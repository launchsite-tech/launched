import "../ui/styles/container.css";
import error from "./utils/error.js";
import { useRef, useState, useEffect } from "react";
import { createRoot } from "react-dom/client";
import type { Tag, TagData, TagValue } from "./context.js";
import type { Root } from "react-dom/client";
import Launched from "./context.js";
import flattenTagValue from "./utils/flattenTagValue.js";

/** @internal Options for rendering a tag.  */
export type TagRenderOptions = Partial<{
  /** Whether a tag with an array value can be mutated (e.g. adding/removing items). */
  arrayMutable: boolean;

  /** The type of the tag. */
  type: string;
}>;

/** @internal Options for rendering a tag with additional information. */
type TagUIOptions = TagRenderOptions & {
  /** The index of the tag in an array. */
  index: number;

  /** The parent tag of a child tag within an object. */
  parentTag: Tag;
};

/** @internal The state of a tag renderer function. */
type TagRendererFunctionState = {
  /** The element that the renderer is bound to. */
  element?: HTMLElement;
};

/** The properties passed to a tag renderer. */
export type TagRendererProps<V> = {
  /**
   * The tag's unique identifier.
   *
   * @remarks
   * Generated by combining the tag's key with its index in an array and/or its key in an object.
   */
  id: string;

  /** The element that the tag is bound to. */
  element: HTMLElement;

  /** The value of the tag. */
  value: V;

  /** Whether the tag is selected. */
  selected: boolean;

  /** The Launched instance that the tag belongs to. */
  context: Launched;

  /**
   * Updates the tag's value.
   *
   * @param data - The new value of the tag
   */
  updateData: (data: V) => void;

  /** Deselects the tag editor. */
  close: () => void;
};

/* A custom tag renderer. */
export type TagRenderer<V> = {
  /**
   * The component that renders the tag.
   *
   * @param props - The properties passed to the renderer
   *
   * @returns The rendered tag
   *
   * @see {@link TagRendererProps}
   */
  component: (props: TagRendererProps<V>) => React.JSX.Element;

  /**
   * Determins whether the parent element satisfies the constraints of the renderer.
   *
   * @param element - The parent element of the tag
   *
   * @returns Whether the parent element satisfies the constraints of the renderer
   *
   * @example
   * ```ts
   * parentValidator: (element) => element.nodeName === "DIV"
   * ```
   */
  parentValidator?: (element: HTMLElement) => boolean;

  /**
   * Called when the tag is deselected.
   *
   * @param state - The state of the tag renderer function
   *
   * @see {@link TagRendererFunctionState}
   */
  onClose?: (state: TagRendererFunctionState) => void;

  /**
   * Called when the tag is selected.
   *
   * @param state - The state of the tag renderer function
   *
   * @see {@link TagRendererFunctionState}
   */
  onSelect?: (state: TagRendererFunctionState) => void;

  /**
   * Called when the tag's value changes.
   *
   * @param state - The state of the tag renderer function
   *
   * @see {@link TagRendererFunctionState}
   */
  onDataUpdate?: (state: TagRendererFunctionState & { data: V }) => void;

  /**
   * Retrieves the static properties of the element.
   *
   * @param el - The element to retrieve the properties from
   *
   * @returns The static properties of the element
   *
   * @remarks
   * Only necessary if you plan to use static mode. Used by the static renderer to fetch the initial value of the tag.
   *
   * @example
   * ```ts
   * getStaticProperties: (el) => el.textContent ?? ""
   * ```
   */
  getStaticProperties?: (el: HTMLElement) => V;

  /**
   * Updates the static properties of the element.
   *
   * @param state - The state of the tag renderer function
   *
   * @see {@link TagRendererFunctionState}
   *
   * @remarks
   * Only necessary if you plan to use static mode. Used by the static renderer to update the value of the tag.
   *
   * @example
   * ```ts
   * updateStaticProperties: (state) => state.element.textContent = state.data
   * ```
   */
  updateStaticProperties?: (
    state: Required<TagRendererFunctionState> & { data: V }
  ) => void;
};

/** Responsible for rendering tag editors. */
export default class Renderer {
  /** Registered custom formats and their associated tag renderers. */
  public static formats = new Map<string, TagRenderer<any>>();

  /** @internal The React roots of all rendered tag editors. */
  public static roots = new Map<string, Root>();

  /** @internal The initial render options of all rendered tag editors. */
  private initialRenderOptions = new Map<string, TagUIOptions>();

  constructor() {}

  /**
   * Registers a custom tag renderer.
   *
   * @param name - The name of the tag format
   * @param renderer - The renderer for the tag format
   *
   * @see {@link TagRenderer}
   */
  public static registerTagFormat<V>(name: string, renderer: TagRenderer<V>) {
    if (!renderer.component) error("Custom renderers must have a component.");

    Renderer.formats.set(name, renderer);
  }

  /**
   * @internal
   *
   * Renders a single tag editor.
   *
   * @param parentTag - The initial tag to render
   * @param id - The tag's name
   * @param options - The options for rendering the tag editor
   * @param dry - Whether to render the tag editor without mounting it
   *
   * @see {@link TagRenderOptions}
   */
  public renderSingleTagUI(
    parentTag: Tag,
    id: string,
    options?: TagRenderOptions,
    dry?: boolean
  ): void {
    if (!parentTag || !parentTag.el.current) return;

    const renderTag = (
      parentTag: Tag,
      tag: Tag,
      childId: string,
      index: number
    ): void => {
      if (!tag.el.current) return console.error("Element is null.");

      if (Array.isArray(tag.data.value)) {
        tag.data.value.forEach((t, i) => {
          const childEl =
            (tag.el.current!.children[i] as HTMLElement) ?? tag.el.current;

          renderTag(
            parentTag,
            {
              el: { current: childEl },
              data: {
                type: tag.data.type,
                value: t,
              },
              setData: (data) => {
                tag.setData(
                  (tag.data.value as TagValue[]).map((v, index) =>
                    index === i
                      ? ((typeof data === "function"
                          ? data(v)
                          : data) as TagValue)
                      : v
                  )
                );
              },
            },
            `${id}-${i}`,
            i
          );
        });
      } else if (
        tag.data.type === "object" &&
        typeof tag.data.value === "object"
      ) {
        for (const key in tag.data.value) {
          const childEl = tag.el.current!.querySelector(
            `[data-key="${key}"]`
          ) as HTMLElement;

          if (!childEl)
            error(
              `Child element with key "${key}" (under "${id}") not found. If you're using a custom renderer, make sure to add a data-key attribute to the targeted element.`
            );

          renderTag(
            parentTag,
            {
              el: { current: childEl },
              data: {
                type: (tag.data.value as Record<string, TagData>)[key]!.type,
                value: tag.data.value[key]!.value,
              },
              setData: (data) => {
                const newValue =
                  typeof data === "function"
                    ? data(
                        (tag.data.value as Record<string, TagData>)[key]!.value
                      )
                    : data;

                tag.setData({
                  ...(tag.data.value as Record<string, TagData>),
                  [key]: {
                    type: (tag.data.value as Record<string, TagData>)[key]!
                      .type,
                    value: newValue,
                  },
                });
              },
            },
            `${childId}-${key}`,
            index
          );
        }
      } else {
        if (!tag.el.current) return;

        const renderer = Renderer.formats.get(tag.data.type);

        if (!renderer) {
          return console.warn(
            `No renderer found for tag type "${tag.data.type}".`
          );
        }

        if (
          renderer.parentValidator &&
          !renderer.parentValidator(tag.el.current)
        ) {
          return console.warn(
            `Parent element of tag "${childId}" does not satisfy the constraints of the "${tag.data.type}" renderer.`
          );
        }

        const id = `Lt-${childId.replaceAll(" ", "-")}`;
        let userOptions: TagUIOptions;

        if (this.initialRenderOptions.get(id))
          userOptions = this.initialRenderOptions.get(id)!;
        else {
          userOptions = {
            arrayMutable: options?.arrayMutable ?? false,
            index,
            parentTag,
          };

          this.initialRenderOptions.set(id, userOptions);
        }

        if (dry) return;

        const existingNode = document.getElementById(id);
        if (existingNode) existingNode.remove();

        setTimeout(() => {
          if (Renderer.roots.get(childId)) {
            Renderer.roots.get(childId)!.unmount();
            Renderer.roots.delete(childId);
          }

          const rootNode = document.createElement("div");
          rootNode.id = id;
          tag.el.current!.appendChild(rootNode);
          const root = createRoot(rootNode);
          Renderer.roots.set(childId, root);

          const t = {
            ...tag,
            data: {
              type: tag.data.type,
              value: flattenTagValue(tag.data.value as any),
            },
          };

          root.render(
            <TagUI
              tag={t}
              renderer={renderer!}
              id={childId}
              options={userOptions}
            />
          );
        }, 0);
      }
    };

    renderTag(parentTag, parentTag, id, 0);
  }

  /**
   * @internal
   *
   * Unmounts a single tag editor.
   *
   * @param tagId - The tag's name
   */
  public unmountSingleTagUI(tagId: string): void {
    const id = `Lt-${tagId.split(" ").join("-")}`;
    const root = Renderer.roots.get(tagId);

    if (root) {
      root.unmount();
      Renderer.roots.delete(tagId);
    }

    const node = document.getElementById(id);
    if (node) node.remove();
  }
}

/** @internal A tag editor. */
function TagUI({
  tag,
  renderer,
  id,
  options,
}: {
  tag: Omit<Tag, "data"> & {
    data: {
      type: string;
      value: any;
    };
  };
  renderer: TagRenderer<any>;
  id: string;
  options: TagUIOptions;
}) {
  const containerRef = useRef<HTMLDivElement>(null);

  const [selected, setSelected] = useState(false);

  const { arrayMutable, parentTag, index } = options;

  function close() {
    setSelected(false);

    containerRef.current?.blur();

    renderer.onClose?.({
      element: tag.el.current ?? undefined,
    });

    Launched.events.emit("tag:deselect", id, tag);
  }

  function updateData(data: any) {
    tag.setData(data);

    // @ts-expect-error
    tag.el.current = null;
  }

  function duplicateTagItem() {
    if (!Array.isArray(parentTag.data.value)) return;

    parentTag.setData((p) => [
      ...(p as TagValue[]).slice(0, index + 1),
      (p as TagValue[])[index]!,
      ...(p as TagValue[]).slice(index + 1),
    ]);
  }

  function removeTagItem() {
    if (!Array.isArray(parentTag.data.value)) return;

    parentTag.setData((p) => [
      ...(p as TagValue[]).slice(0, index),
      ...(p as TagValue[]).slice(index + 1),
    ]);
  }

  function onTagSelect(selectedId: string) {
    if (selectedId !== id) setSelected(false);
  }

  useEffect(() => {
    if (!tag.el.current) error("Element is null.");

    tag.el.current.classList.add("tagged");

    if (getComputedStyle(tag.el.current).position === "static") {
      tag.el.current.style.position = "relative";
    }

    Launched.events.emit("tag:mount", id, tag);

    Launched.events.on("tag:select", onTagSelect);

    return () => {
      Launched.events.emit("tag:unmount", id, tag);

      Launched.events.off("tag:select", onTagSelect);
    };
  }, []);

  useEffect(() => {
    const state = {
      element: tag.el.current ?? undefined,
      data: tag.data.value,
    };

    renderer.onDataUpdate?.(state);

    if (Launched.instance!.config.mode === "static" && state.element) {
      const changed =
        renderer.getStaticProperties?.(state.element) !== state.data;
      if (changed) renderer.updateStaticProperties?.(state as any);
    }
  }, [tag.data.value]);

  function select() {
    if (selected) return;

    setSelected(true);
    renderer?.onSelect?.({ element: tag.el.current! });

    Launched.events.emit("tag:select", id, tag);
  }

  if (!tag.el.current) return null;

  return (
    <div
      ref={containerRef}
      tabIndex={0}
      onMouseDown={select}
      onFocus={select}
      className={`Launched__tag-container ${selected && "active"}`}
    >
      <renderer.component
        element={tag.el.current}
        value={tag.data.value}
        selected={selected}
        updateData={updateData}
        close={close}
        id={id}
        context={Launched.instance!}
      />
      {arrayMutable && (
        <div
          onMouseDown={(e) => e.preventDefault()}
          className="Launched__tag-arrayControls Launched__toolbar-tools"
        >
          <button
            className="Launched__toolbar-button add"
            onClick={duplicateTagItem}
          >
            <svg viewBox="0 0 24 24" className="Launched__icon">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
          <button className="Launched__button remove" onClick={removeTagItem}>
            <svg viewBox="0 0 24 24" className="Launched__icon">
              <polyline points="3 6 5 6 21 6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
          </button>
        </div>
      )}
    </div>
  );
}
